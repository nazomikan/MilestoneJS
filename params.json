{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Milestonejs","tagline":"newer promised/A library","body":"<a name=\"README\">[MilestoneJS](https://github.com/nazomikan/MilestoneJS)</a>\r\n=======\r\n\r\n**This is a library of asynchronous flow control, which is based on Promises/A.**\r\n\r\n\r\nThis library can express asynchronous processing more nearly intuitively.\r\nAnd processing can be made to hook more flexibly by including EventEmitter further compared with general Promises/A library.\r\n\r\n\r\n\r\n**Table of contents**\r\n\r\n* [Usage](#Usage)\r\n* [The API](#TheAPI)\r\n\r\n## <a name=\"Usage\">Usage</a>\r\n\r\n**in Node.js**\r\n\r\ninstall MilestoneJS with github `npm install milestonejs`, then require it as below.\r\n\r\n    var Milestone = require('milestonejs').Milestone;\r\n      , milestone = new Milestone()\r\n      ;\r\n\r\n**in HTML**\r\n\r\nload MilestoneJS as a script `<script type=\"text/javascript\" src=\"/path/to/milestone-csjs.js\"></script>`, then require it as below.\r\n\r\n    var milestone = new milestoneJS.Milestone();\r\n\r\nThen, write your module with `milestone`.\r\n\r\n    var milestoneJS = require('milestonejs')\r\n      , Milestone = milestoneJS.Milestone\r\n      , mission\r\n      , mission2\r\n      ;\r\n\r\n    function countTenSecond() {\r\n      var milestone = new Milestone()\r\n        ;\r\n\r\n      (function a(idx) {\r\n        var baseCamp;\r\n\r\n        if (idx === 10) {\r\n          milestone.complete(idx);\r\n          return;\r\n        } else {\r\n          baseCamp = 'baseCamp' + idx;\r\n          milestone.comeAt(baseCamp, idx);\r\n        }\r\n\r\n        setTimeout(function () {\r\n          a(++idx);\r\n        }, 1000);\r\n      }(0));\r\n\r\n      return milestone.mission;\r\n    }\r\n\r\n    mission = countTenSecond();\r\n    mission.on('baseCamp1', function (idx) {\r\n      console.log('1 second passed');\r\n    });\r\n\r\n    mission.on('baseCamp2', function (idx) {\r\n      console.log('2 second passed');\r\n    });\r\n\r\n    mission.complete(function (time) {\r\n      console.log('10 second passed');\r\n    });\r\n\r\n    mission2 = countTenSecond();\r\n\r\n    milestoneJS.when({\r\n      a: mission,\r\n      b: mission2\r\n    }).complete(function (res) {\r\n      console.log(res.a);\r\n      console.log(res.b);\r\n    });\r\n\r\n## <a name=\"TheAPI\">The API</a>\r\n\r\nHere is the whole API\r\n\r\n**Milestone Object / Mission Object**\r\n\r\nInstance of Milestone can be obtained as follows.\r\n\r\n    var milestoneJS = require('milestonejs')\r\n      , milestone = new milestoneJS.Milestone()\r\n      ;\r\n\r\nBy using milestoneJS, function returns `mission object`, without waiting for the delayed processing.\r\nMoreover, bind of the processing can be carried out by registering callback into `mission object` at the time of completion of delay processing.\r\n\r\n    function delay() {\r\n      var milestone = new milestoneJS.Milestone()\r\n        ;\r\n\r\n      setTimeout(function () {\r\n      \tmilestone.complete('done');\r\n      }, 100);\r\n\r\n      return milestone.mission;\r\n    }\r\n\r\n    delay().complete(function (msg) {\r\n      console.log(msg); // output 'done'\r\n    });\r\n\r\nMoreover, not only the state of completion but its process can also be notified.\r\n\r\n    function delay() {\r\n      var milestone = new milestoneJS.Milestone()\r\n        ;\r\n\r\n      setTimeout(function () {\r\n      \tmilestone.comeAt('herf', '50msec ago');\r\n      \tsetTimeout(function () {\r\n      \t  milestone.complete('done');\r\n      \t}, 50);\r\n      }, 50);\r\n      return milestone.mission;\r\n    }\r\n\r\n    delay().on('herf', function (msg) {\r\n      console.log(msg); // output '50msec ago'\r\n    }).complete(function (msg) {\r\n      console.log(msg); // output 'done'\r\n    });\r\n\r\nOf course, failure in processing is also detectable.\r\n\r\n    function delay() {\r\n      var milestone = new milestoneJS.Milestone()\r\n        ;\r\n\r\n      setTimeout(function () {\r\n      \ttry {\r\n      \t  new Error('fuckin');\r\n      \t} catch(err) {\r\n      \t  milestone.reject(err);\r\n      \t}\r\n      }, 50);\r\n      return milestone.mission;\r\n    }\r\n\r\n    delay().fail(function (err) {\r\n      console.log(err.message); // output 'fuckin'\r\n    });\r\n\r\n`then` is used to define the processing at the time of a success and failure simultaneously.\r\n\r\narg1: success callback\r\n\r\narg2: fail callback\r\n\r\n    function delay() {\r\n      var milestone = new milestoneJS.Milestone()\r\n        ;\r\n\r\n      setTimeout(function () {\r\n      \ttry {\r\n      \t  if (+new Date % 2 === 0) {\r\n      \t    milestone.complete('done')\r\n      \t  } else {\r\n      \t    throw new Error('fuckin');\r\n      \t  }\r\n      \t} catch(err) {\r\n      \t  milestone.reject(err);\r\n      \t}\r\n      }, 50);\r\n      return milestone.mission;\r\n    }\r\n\r\n    // arg1 callback will be performed if it succeeds.\r\n    // However, arg2 callback will be performed if it has failed.\r\n    delay().then(function (msg) {\r\n    \tconsole.log(msg); // output 'done'\r\n    }, function (err) {\r\n    \tconsole.log(err.message); // output 'fuckin'\r\n    });\r\n\r\n\r\nYou might want to use `mission.finish()` if you want to execute when processing regardless of success or failure, `mission` is finished.\r\n\r\n    var milestone = new milestoneJS.Milestone()\r\n      , mission = milestone.mission\r\n      ;\r\n\r\n    setTimeout(function () {\r\n      if (+new Date % 2 === 0) {\r\n        milestone.complete('done');\r\n      } else {\r\n        milestone.reject('oops');\r\n      }\r\n    }, 1);\r\n\r\n    mission.finish(function (msg) {\r\n      console.log(msg); // output 'done' or 'oops'\r\n    });\r\n\r\n\r\nBranch of processing according to the state of `mission` is attained by using `mission.isCompleted()` and `mission.isRejected()`.\r\n\r\n    var milestone = new milestoneJS.Milestone()\r\n      , mission = milestone.mission\r\n      , assert = require('assert')\r\n      ;\r\n\r\n    milestone.completed('done');\r\n    assert.ok(mission.isCompleted()); // pass\r\n    assert.fail(mission.isRejected()); // pass\r\n\r\n\r\n**when method**\r\n\r\n`when` will be used if processing is related with the end status of two or more `mission`.\r\n\r\nBy using `when`, two or more `mission` can be treated just like one `mission`.\r\n\r\n    function delay() {\r\n      var milestone = new milestoneJS.Milestone()\r\n        ;\r\n\r\n      setTimeout(function () {\r\n      \tmission.complete('done');\r\n      }, 50);\r\n\r\n      return milestone.mission;\r\n    }\r\n\r\n    var mission1 = delay();\r\n    var mission2 = delay();\r\n\r\n    milestoneJS.when({\r\n      a: mission1,\r\n      b: mission2\r\n    }).complete(function (res) {\r\n      console.log(res.a); // output 'done'\r\n      console.log(res.b); // output 'done'\r\n    }).fail(function (err) {\r\n      console.log(err);\r\n    });\r\n\r\n\r\nIn addition, you can use an `Mission.createBaseCamp()` also offers state management of multiple `Mission` as well as the state management of multiple `milestone`.\r\n`Mission.createBaseCamp()` returns a new `Mission` that is completed at the timing of the `Mission.comeAt('...')`.\r\n\r\n    function delay() {\r\n      var milestone = new milestoneJS.Milestone()\r\n        ;\r\n\r\n      setTimeout(function (timer) {\r\n      \tmilestone.comeAt('herf', 'Half the time has elapsed.');\r\n      \tsetTimeout(function () {\r\n      \t  milestone.complete('done');\r\n      \t}, timer / 2);\r\n      }, timer / 2);\r\n      return milestone.mission;\r\n    }\r\n\r\n    var mission1 = delay(200);\r\n    var mission2 = delay(300);\r\n\r\n    milestoneJS.when({\r\n      a: mission1.createBaseCamp('herf'),\r\n      b: mission2\r\n    }).complete(function (res) {\r\n      console.log(res.a); // output 'Half the time has elapsed.'\r\n      console.log(res.b); // output 'done'\r\n    });\r\n","google":""}